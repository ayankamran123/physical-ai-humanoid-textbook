"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[89],{4746:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"chapter-02","title":"Chapter 2","description":"Chapter 02: Robot Kinematics","source":"@site/docs/chapter-02.md","sourceDirName":".","slug":"/chapter-02","permalink":"/physical-ai-humanoid-textbook/docs/chapter-02","draft":false,"unlisted":false,"editUrl":"https://github.com/ayankamran123/physical-ai-humanoid-textbook/tree/main/docs/chapter-02.md","tags":[],"version":"current","frontMatter":{"id":"chapter-02","title":"Chapter 2","sidebar_label":"Chapter 2"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1","permalink":"/physical-ai-humanoid-textbook/docs/chapter-01"},"next":{"title":"Chapter 3","permalink":"/physical-ai-humanoid-textbook/docs/chapter-03"}}');var s=i(4848),o=i(8453);const a={id:"chapter-02",title:"Chapter 2",sidebar_label:"Chapter 2"},r=void 0,l={},c=[{value:"Chapter 02: Robot Kinematics",id:"chapter-02-robot-kinematics",level:3},{value:"Learning Objectives",id:"learning-objectives",level:4},{value:"Theory Explanation",id:"theory-explanation",level:4},{value:"Diagrams",id:"diagrams",level:4},{value:"Python/ROS2 Code Examples",id:"pythonros2-code-examples",level:4},{value:"1. Homogeneous Transformation and 2D Forward Kinematics (Python)",id:"1-homogeneous-transformation-and-2d-forward-kinematics-python",level:5},{value:"2. Conceptual Jacobian for a 2-DOF Planar Arm (Python)",id:"2-conceptual-jacobian-for-a-2-dof-planar-arm-python",level:5},{value:"Exercises + MCQs",id:"exercises--mcqs",level:4},{value:"Exercises",id:"exercises",level:5},{value:"Multiple Choice Questions",id:"multiple-choice-questions",level:5}];function d(e){const n={admonition:"admonition",code:"code",h3:"h3",h4:"h4",h5:"h5",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"chapter-02-robot-kinematics",children:"Chapter 02: Robot Kinematics"}),"\n",(0,s.jsx)(n.h4,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(n.p,{children:"After studying this chapter, you should be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Differentiate rigorously between Forward Kinematics (FK) and Inverse Kinematics (IK), including their computational complexities and common applications."}),"\n",(0,s.jsx)(n.li,{children:"Systematically apply the Denavit-Hartenberg (DH) convention to establish coordinate frames and derive kinematic parameters for multi-link robot manipulators."}),"\n",(0,s.jsx)(n.li,{children:"Construct and compose homogeneous transformation matrices to represent the position and orientation of robot links and end-effectors in 3D space."}),"\n",(0,s.jsx)(n.li,{children:"Derive and interpret the Jacobian matrix for robotic systems, understanding its role in velocity mapping, singularity analysis, and static force analysis."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"theory-explanation",children:"Theory Explanation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2.1 Introduction to Robot Kinematics"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Robot Kinematics"})," is a foundational branch of robotics that deals with the study of motion without considering the forces and torques that cause the motion. It focuses on the geometric relationships between the robot's joint variables (e.g., angles of revolute joints, linear displacements of prismatic joints) and the position and orientation of its end-effector or any point of interest in its workspace. A thorough understanding of kinematics is prerequisite for dynamics, control, and path planning."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2.2 Forward Kinematics (FK)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Forward Kinematics (FK)"})," is the direct mapping from the robot's joint space to its task space. Given the values of all joint variables, FK calculates the resulting position and orientation of the end-effector relative to a fixed base coordinate frame. This is a deterministic and usually straightforward computation, typically involving sequential multiplication of transformation matrices."]}),"\n",(0,s.jsxs)(n.p,{children:["For an ",(0,s.jsx)(n.code,{children:"n"}),"-DOF robot, if ",(0,s.jsx)(n.code,{children:"q = [q1, q2, ..., qn]^T"})," represents the vector of joint variables, Forward Kinematics computes ",(0,s.jsx)(n.code,{children:"X = f(q)"}),", where ",(0,s.jsx)(n.code,{children:"X"})," is the end-effector's pose (position and orientation) in Cartesian space."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Applications of FK include:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Visualizing the robot's configuration given joint commands."}),"\n",(0,s.jsx)(n.li,{children:"Determining if a specific joint configuration causes a collision."}),"\n",(0,s.jsx)(n.li,{children:"Generating sensor expectations (e.g., where a camera should be pointing)."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2.3 Inverse Kinematics (IK)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Inverse Kinematics (IK)"})," is the inverse problem of FK: given a desired position and orientation of the end-effector in task space, IK determines the corresponding set of joint variables (",(0,s.jsx)(n.code,{children:"q"}),") that can achieve that pose. This is generally a much more complex and computationally intensive problem than FK due to several factors:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Non-linearity"}),": The relationship between joint variables and end-effector pose is often non-linear, especially for robots with many degrees of freedom."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multiple Solutions"}),': A desired end-effector pose may be reachable by several different joint configurations (e.g., an "elbow up" or "elbow down" solution for a human arm-like manipulator).']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No Solutions"}),": The desired pose might be outside the robot's workspace, meaning no valid joint configuration exists."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Singularities"}),": Certain joint configurations (singularities) can lead to a loss of degrees of freedom in the task space, making IK difficult or impossible to solve at those points."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"IK can be solved using analytical methods (for simpler robots) or numerical/iterative methods (for complex or redundant robots). Numerical methods often involve Jacobian-based approaches (discussed below)."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Applications of IK include:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Task-space control, where a robot needs to precisely follow a path or trajectory in Cartesian space (e.g., welding, painting, grasping)."}),"\n",(0,s.jsx)(n.li,{children:"Human-robot collaboration, where the robot mimics human movements."}),"\n",(0,s.jsx)(n.li,{children:"Path planning, where IK is used to convert desired end-effector waypoints into executable joint trajectories."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2.4 Denavit-Hartenberg (DH) Convention"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Denavit-Hartenberg (DH) Convention"})," provides a systematic and standardized method for assigning coordinate frames to each link of a serial robot manipulator and for deriving the transformation matrices between adjacent links. This convention simplifies the derivation of the forward kinematics equation for complex robotic arms."]}),"\n",(0,s.jsxs)(n.p,{children:["For each link ",(0,s.jsx)(n.code,{children:"i"})," in a robot chain, a coordinate frame ",(0,s.jsx)(n.code,{children:"{i}"})," is attached. The transformation from frame ",(0,s.jsx)(n.code,{children:"{i-1}"})," to frame ",(0,s.jsx)(n.code,{children:"{i}"})," is defined by four parameters:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"-i"})," (Link Length)"]}),": The distance along the common normal between the ",(0,s.jsx)(n.code,{children:"z_{i-1}"})," and ",(0,s.jsx)(n.code,{children:"z_i"})," axes. It is the shortest distance between the two joint axes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"\u03b1_i"})," (Link Twist)"]}),": The angle from the ",(0,s.jsx)(n.code,{children:"z_{i-1}"})," axis to the ",(0,s.jsx)(n.code,{children:"z_i"})," axis, measured about the common normal. It describes how much the ",(0,s.jsx)(n.code,{children:"z_i"}),' axis is "twisted" relative to ',(0,s.jsx)(n.code,{children:"z_{i-1}"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"d_i"})," (Link Offset)"]}),": The distance along the ",(0,s.jsx)(n.code,{children:"z_{i-1}"})," axis from the origin of frame ",(0,s.jsx)(n.code,{children:"{i-1}"})," to the intersection of the ",(0,s.jsx)(n.code,{children:"z_{i-1}"})," axis with the common normal. For a revolute joint, this is typically constant. For a prismatic joint, ",(0,s.jsx)(n.code,{children:"d_i"})," is the joint variable."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"\u03b8_i"})," (Joint Angle)"]}),": The angle from the ",(0,s.jsx)(n.code,{children:"x_{i-1}"})," axis to the ",(0,s.jsx)(n.code,{children:"x_i"})," axis, measured about the ",(0,s.jsx)(n.code,{children:"z_{i-1}"})," axis. For a revolute joint, this is the joint variable. For a prismatic joint, ",(0,s.jsx)(n.code,{children:"\u03b8_i"})," is typically constant."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The general homogeneous transformation matrix ",(0,s.jsx)(n.code,{children:"A_i^{i-1}"})," from frame ",(0,s.jsx)(n.code,{children:"{i-1}"})," to frame ",(0,s.jsx)(n.code,{children:"{i}"})," using DH parameters is:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"A_{i}^{i-1} =\n  Rot(z_{i-1}, \\thet-i) \\cdot Trans(z_{i-1}, d_i) \\cdot Trans(x_i, -i) \\cdot Rot(x_i, \\alph-i)\n\n= [[cos(\\thet-i), -sin(\\thet-i)cos(\\alph-i), sin(\\thet-i)sin(\\alph-i), -i cos(\\thet-i)],\n   [sin(\\thet-i),  cos(\\thet-i)cos(\\alph-i), -cos(\\thet-i)sin(\\alph-i), -i sin(\\thet-i)],\n   [0,               sin(\\alph-i),             cos(\\alph-i),             d_i],\n   [0,               0,                         0,                         1]]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The full forward kinematics from the base frame ",(0,s.jsx)(n.code,{children:"{0}"})," to the end-effector frame ",(0,s.jsx)(n.code,{children:"{N}"})," is then the product of these successive transformation matrices:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"T_N^0 = A_1^0 A_2^1 ... A_N^{N-1}"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2.5 Homogeneous Transformation Matrices"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Homogeneous Transformation Matrices"})," (HTMs) are 4x4 matrices that combine both rotation and translation into a single mathematical entity. They provide a concise and powerful way to represent the pose (position and orientation) of one coordinate frame relative to another in 3D Euclidean space. A general HTM ",(0,s.jsx)(n.code,{children:"T"})," is structured as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"T = [[R_{3x3}, p_{3x1}],\n     [0_{1x3}, 1_{1x1}]]\n"})}),"\n",(0,s.jsx)(n.p,{children:"Where:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"R_{3x3}"})," is a 3x3 rotation matrix, representing the orientation of the new frame's axes with respect to the reference frame."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"p_{3x1}"})," is a 3x1 position vector, representing the origin of the new frame with respect to the reference frame."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"0_{1x3}"})," is a 1x3 zero vector."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"1_{1x1}"})," is a scalar one."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["HTMs allow for sequential transformations to be composed by matrix multiplication: if ",(0,s.jsx)(n.code,{children:"T_B^A"})," transforms points from frame ",(0,s.jsx)(n.code,{children:"{B}"})," to frame ",(0,s.jsx)(n.code,{children:"{A}"}),", and ",(0,s.jsx)(n.code,{children:"T_C^B"})," transforms points from frame ",(0,s.jsx)(n.code,{children:"{C}"})," to frame ",(0,s.jsx)(n.code,{children:"{B}"}),", then ",(0,s.jsx)(n.code,{children:"T_C^A = T_B^A T_C^B"})," transforms points from ",(0,s.jsx)(n.code,{children:"{C}"})," to ",(0,s.jsx)(n.code,{children:"{A}"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2.6 The Jacobian Matrix"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Jacobian Matrix"})," (",(0,s.jsx)(n.code,{children:"J"}),") in robotics is a fundamental tool that relates velocities in the robot's joint space to velocities in its task space (Cartesian space). Specifically, it maps joint velocities (",(0,s.jsx)(n.code,{children:"q\u0307"}),") to the linear (",(0,s.jsx)(n.code,{children:"v"}),") and angular (",(0,s.jsx)(n.code,{children:"\u03c9"}),") velocities of the end-effector:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"[v; \u03c9] = J(q) * q\u0307"})}),"\n",(0,s.jsx)(n.p,{children:"Where:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"J(q)"})," is the ",(0,s.jsx)(n.code,{children:"6 x n"})," Jacobian matrix, dependent on the current joint configuration ",(0,s.jsx)(n.code,{children:"q"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"q\u0307"})," is the ",(0,s.jsx)(n.code,{children:"n x 1"})," vector of joint velocities."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[v; \u03c9]"})," is the ",(0,s.jsx)(n.code,{children:"6 x 1"})," vector representing the end-effector's linear and angular velocities."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key applications and insights from the Jacobian:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Velocity Analysis"}),": Directly computes end-effector velocities from joint velocities."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inverse Kinematics"}),": For redundant robots or in numerical IK methods, ",(0,s.jsx)(n.code,{children:"q\u0307 = J\u207a(q) * [v; \u03c9]"})," (where ",(0,s.jsx)(n.code,{children:"J\u207a"})," is the pseudo-inverse) can be used to compute joint velocities to achieve desired end-effector velocities."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Singularity Analysis"}),": Robot singularities occur when the Jacobian matrix loses rank (i.e., its determinant is zero, or it does not have full rank). At these configurations, the robot effectively loses one or more degrees of freedom in its task space, meaning it cannot move its end-effector in certain directions despite non-zero joint velocities. Singularities are critical to avoid in robot operation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Static Force Analysis"}),": The transpose of the Jacobian (",(0,s.jsx)(n.code,{children:"J^T"}),") relates forces/torques in task space to torques in joint space (e.g., ",(0,s.jsx)(n.code,{children:"\u03c4 = J^T * F"}),"), which is important for understanding wrench propagation and control."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"diagrams",children:"Diagrams"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    subgraph Robot Kinematics\n        FK[Forward Kinematics] -- q --\x3e EE_Pose(End-Effector Pose);\n        EE_Pose -- X --\x3e IK[Inverse Kinematics];\n        IK -- q --\x3e FK;\n\n        subgraph DH Parameters\n            L1(Link 1 DH) --\x3e TM1(Transform Matrix 1);\n            L2(Link 2 DH) --\x3e TM2(Transform Matrix 2);\n            TM1 --\x3e TM_COMPOSITION(Composition of HTMs);\n            TM2 --\x3e TM_COMPOSITION;\n            TM_COMPOSITION --\x3e EE_Pose;\n        end\n\n        subgraph Jacobian Analysis\n            JV(Joint Velocities q_dot) --\x3e JM(Jacobian Matrix J(q));\n            JM --\x3e TV(Task Space Velocities [v, omega]);\n            JM --\x3e Singularities(Singularity Analysis);\n        end\n    end\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 2.1: Integrated View of Robot Kinematics Concepts"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    Joint1(Joint 1 Angle) --\x3e Link1(Link 1);\n    Joint2(Joint 2 Angle) --\x3e Link2(Link 2);\n    Link1 & Link2 --\x3e EndEffector(End-Effector Position/Orientation);\n\n    style Joint1 fill:#fff,stroke:#333,stroke-width:1px;\n    style Link1 fill:#DCEFFB,stroke:#333,stroke-width:1px;\n    style Joint2 fill:#fff,stroke:#333,stroke-width:1px;\n    style Link2 fill:#DCEFFB,stroke:#333,stroke-width:1px;\n    style EndEffector fill:#F9F,stroke:#333,stroke-width:2px;\n\n    subgraph Forward Kinematics (FK)\n        FK_Input(Joint Angles) --\x3e FK_Process(Geometric Calculations) --\x3e FK_Output(End-Effector Pose);\n    end\n\n    subgraph Inverse Kinematics (IK)\n        IK_Input(Desired End-Effector Pose) --\x3e IK_Process(Solver Algorithm) --\x3e IK_Output(Joint Angles);\n    end\n\n    FK_Output -- Used by --\x3e IK_Input;\n    IK_Output -- Controls --\x3e FK_Input;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Figure 2.2: Forward vs. Inverse Kinematics Relationship"})}),"\n",(0,s.jsx)(n.h4,{id:"pythonros2-code-examples",children:"Python/ROS2 Code Examples"}),"\n",(0,s.jsx)(n.h5,{id:"1-homogeneous-transformation-and-2d-forward-kinematics-python",children:"1. Homogeneous Transformation and 2D Forward Kinematics (Python)"}),"\n",(0,s.jsx)(n.p,{children:"This expanded Python example provides functions for 2D rotations, translations, and constructing homogeneous transformation matrices. It then applies these to a 2-DOF planar arm to calculate its forward kinematics."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import numpy as np\nimport math\n\ndef rot_z(angle_rad):\n    """Generates a 2D rotation matrix around the Z-axis (for 3D context, this is a Z-rotation)."""\n    c = math.cos(angle_rad)\n    s = math.sin(angle_rad)\n    return np.array([[c, -s, 0],\n                     [s,  c, 0],\n                     [0,  0, 1]])\n\ndef trans_xyz(x, y, z):\n    """Generates a 3D translation vector."""\n    return np.array([x, y, z])\n\ndef homogeneous_transform_matrix(rotation_matrix, translation_vector):\n    """Constructs a 4x4 homogeneous transformation matrix.\n    rotation_matrix: 3x3 numpy array\n    translation_vector: 3x1 numpy array\n    """\n    T = np.eye(4)\n    T[:3, :3] = rotation_matrix\n    T[:3, 3] = translation_vector\n    return T\n\ndef forward_kinematics_2d_planar_arm(L1, L2, theta1_rad, theta2_rad):\n    """Calculates the end-effector position (x, y) for a 2-DOF planar arm.\n    L1, L2: Link lengths\n    theta1_rad, theta2_rad: Joint angles in radians (from the previous link or base)\n    """\n    # Position of joint 1 (relative to base, which is origin)\n    x1 = L1 * math.cos(theta1_rad)\n    y1 = L1 * math.sin(theta1_rad)\n\n    # Position of end-effector (relative to base)\n    # The angle for the second link is relative to the first link\n    x_ee = x1 + L2 * math.cos(theta1_rad + theta2_rad)\n    y_ee = y1 + L2 * math.sin(theta1_rad + theta2_rad)\n\n    return x_ee, y_ee\n\nif __name__ == "__main__":\n    # Example: 2-DOF planar arm\n    link1_length = 1.0  # meters\n    link2_length = 0.8  # meters\n    joint1_angle = math.pi / 6  # 30 degrees\n    joint2_angle = math.pi / 4  # 45 degrees\n\n    ee_x, ee_y = forward_kinematics_2d_planar_arm(link1_length, link2_length, joint1_angle, joint2_angle)\n    print(f"End-effector position for 2-DOF arm: ({ee_x:.3f}, {ee_y:.3f}) meters")\n\n    # Example: Constructing and composing Homogeneous Transformation Matrices\n    # Transformation from Frame 0 to Frame 1 (rotation + translation)\n    R0_1 = rot_z(math.pi / 4) # Rotate 45 deg around Z\n    p0_1 = trans_xyz(0.5, 0.2, 0.0) # Translate by (0.5, 0.2, 0)\n    T0_1 = homogeneous_transform_matrix(R0_1, p0_1)\n    print("\\nTransformation T0_1 (Frame 0 to Frame 1):")\n    print(T0_1)\n\n    # Transformation from Frame 1 to Frame 2 (only translation)\n    R1_2 = np.eye(3) # No rotation\n    p1_2 = trans_xyz(0.3, 0.0, 0.0) # Translate by (0.3, 0, 0) along its own X\n    T1_2 = homogeneous_transform_matrix(R1_2, p1_2)\n    print("\\nTransformation T1_2 (Frame 1 to Frame 2):")\n    print(T1_2)\n\n    # Compose transformations: T0_2 = T0_1 * T1_2\n    T0_2 = np.dot(T0_1, T1_2)\n    print("\\nComposed Transformation T0_2 (Frame 0 to Frame 2):")\n    print(T0_2)\n\n    # Extract position and orientation from T0_2\n    final_position = T0_2[:3, 3]\n    final_orientation_matrix = T0_2[:3, :3]\n    print(f"\\nFinal Position of Frame 2 wrt Frame 0: {final_position}")\n    print(f"Final Orientation Matrix of Frame 2 wrt Frame 0:\\n{final_orientation_matrix}")\n'})}),"\n",(0,s.jsx)(n.h5,{id:"2-conceptual-jacobian-for-a-2-dof-planar-arm-python",children:"2. Conceptual Jacobian for a 2-DOF Planar Arm (Python)"}),"\n",(0,s.jsx)(n.p,{children:"This example conceptually derives and shows the structure of a Jacobian for a simple 2-DOF planar arm, relating joint angular velocities to end-effector linear velocities. A full analytical derivation would be more involved but this captures the essence."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import numpy as np\nimport math\n\ndef calculate_jacobian_2d_planar_arm(L1, L2, theta1_rad, theta2_rad):\n    """Calculates the Jacobian matrix for a 2-DOF planar arm.\n    J relates [theta1_dot, theta2_dot] to [x_dot, y_dot].\n    """\n    # Partial derivatives of x_ee and y_ee with respect to theta1 and theta2\n    # x_ee = L1 * cos(theta1) + L2 * cos(theta1 + theta2)\n    # y_ee = L1 * sin(theta1) + L2 * sin(theta1 + theta2)\n\n    # dx_ee/d(theta1)\n    J11 = -L1 * math.sin(theta1_rad) - L2 * math.sin(theta1_rad + theta2_rad)\n    # dx_ee/d(theta2)\n    J12 = -L2 * math.sin(theta1_rad + theta2_rad)\n\n    # dy_ee/d(theta1)\n    J21 = L1 * math.cos(theta1_rad) + L2 * math.cos(theta1_rad + theta2_rad)\n    # dy_ee/d(theta2)\n    J22 = L2 * math.cos(theta1_rad + theta2_rad)\n\n    Jacobian = np.array([\n        [J11, J12],\n        [J21, J22]\n    ])\n    return Jacobian\n\nif __name__ == "__main__":\n    link1_length = 1.0  # meters\n    link2_length = 0.8  # meters\n    joint1_angle = math.pi / 6  # 30 degrees\n    joint2_angle = math.pi / 4  # 45 degrees\n\n    J_arm = calculate_jacobian_2d_planar_arm(link1_length, link2_length, joint1_angle, joint2_angle)\n    print("Jacobian Matrix for 2-DOF Planar Arm:")\n    print(np.array2string(J_arm, precision=3, separator=\',\', suppress_small=True))\n\n    # Example: Calculate end-effector velocity for given joint velocities\n    joint_velocities = np.array([0.1, 0.2]) # rad/s for theta1_dot, theta2_dot\n    ee_velocities = np.dot(J_arm, joint_velocities)\n    print(f"\\nJoint Velocities (rad/s): {joint_velocities}")\n    print(f"End-effector Velocities (m/s): {ee_velocities}")\n\n    # Singularity Check: determinant of Jacobian is zero\n    det_J = np.linalg.det(J_arm)\n    print(f"\\nDeterminant of Jacobian: {det_J:.3f}")\n    if abs(det_J) < 1e-6: # Check if determinant is close to zero\n        print("Warning: Robot is near a kinematic singularity!")\n    else:\n        print("Robot is in a non-singular configuration.")\n\n    # Example of a singular configuration (arm fully extended or folded)\n    print("\\n--- Testing a Singular Configuration ---")\n    singular_J = calculate_jacobian_2d_planar_arm(1.0, 1.0, 0.0, 0.0) # Fully extended\n    print("Jacobian at singular config (theta1=0, theta2=0):")\n    print(np.array2string(singular_J, precision=3, separator=\',\', suppress_small=True))\n    print(f"Determinant: {np.linalg.det(singular_J):.3f}")\n    if abs(np.linalg.det(singular_J)) < 1e-6:\n        print("Correctly identified singularity.")\n'})}),"\n",(0,s.jsx)(n.h4,{id:"exercises--mcqs",children:"Exercises + MCQs"}),"\n",(0,s.jsx)(n.h5,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DH Parameter Application (Advanced)"}),": For a 3-DOF spherical wrist (three revolute joints whose axes intersect at a single point), apply the DH convention to assign frames and derive the DH parameters. Explain why this specific configuration simplifies kinematics. Assume the first joint rotates about Z, the second about Y, and the third about Z again."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inverse Kinematics Challenge"}),": Explain, with a concrete example (e.g., a 6-DOF industrial arm), why Inverse Kinematics often yields multiple solutions. How might a robot controller decide which solution to choose in a practical scenario (e.g., avoiding obstacles, minimizing joint travel)?"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Jacobian for a Cylindrical Robot"}),": A cylindrical robot has a revolute joint for rotation about the Z-axis, followed by a prismatic joint for vertical extension along the Z-axis, and another prismatic joint for radial extension. Qualitatively describe how you would construct its Jacobian matrix to relate joint velocities (angular velocity for revolute, linear velocities for prismatic) to the end-effector's linear velocity components (",(0,s.jsx)(n.code,{children:"vx"}),", ",(0,s.jsx)(n.code,{children:"vy"}),", ",(0,s.jsx)(n.code,{children:"vz"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Singularity Avoidance"}),": Describe a real-world task where encountering a robot singularity would be problematic. Suggest two strategies that could be employed in path planning or control to avoid such singular configurations."]}),"\n"]}),"\n",(0,s.jsx)(n.h5,{id:"multiple-choice-questions",children:"Multiple Choice Questions"}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"Which of the following statements is TRUE regarding Forward Kinematics (FK) and Inverse Kinematics (IK)?"}),(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","FK is generally more complex to compute than IK."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","IK often has multiple solutions, while FK typically has one unique solution."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","FK calculates joint angles from end-effector pose, while IK calculates end-effector pose from joint angles."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Both FK and IK are used to determine forces acting on robot joints."]}),"\n"]})]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["What do the four parameters (",(0,s.jsx)(n.code,{children:"a"}),", ",(0,s.jsx)(n.code,{children:"\u03b1"}),", ",(0,s.jsx)(n.code,{children:"d"}),", ",(0,s.jsx)(n.code,{children:"\u03b8"}),") in the Denavit-Hartenberg (DH) convention define?"]}),(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","The material properties of each robot link."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","The forces and torques acting on each joint."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","The geometric relationship between successive coordinate frames of a robot manipulator."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","The maximum speed and acceleration limits of a robot."]}),"\n"]})]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"Homogeneous Transformation Matrices (HTMs) are used to combine which two types of transformations into a single matrix?"}),(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Scaling and Shearing"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Rotation and Translation"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Reflection and Projection"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Velocity and Acceleration"]}),"\n"]})]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["A robot is said to be in a ",(0,s.jsx)(n.strong,{children:"kinematic singularity"})," when:"]}),(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All its joints are locked in place."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","It has achieved its maximum operational speed."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Its Jacobian matrix loses rank, resulting in a loss of task-space degrees of freedom."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","It successfully grasps an object."]}),"\n"]})]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"The Jacobian matrix relates:"}),(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","End-effector forces to joint torques."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Joint positions to end-effector positions."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Joint velocities to end-effector linear and angular velocities."]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Robot mass to gravity."]}),"\n"]})]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var t=i(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);