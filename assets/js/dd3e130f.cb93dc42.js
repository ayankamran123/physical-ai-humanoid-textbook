"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[1321],{1714:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"chapter-04","title":"Chapter 4","description":"Chapter 04: Control Systems","source":"@site/docs/chapter-04.md","sourceDirName":".","slug":"/chapter-04","permalink":"/physical-ai-humanoid-textbook/docs/chapter-04","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapter-04.md","tags":[],"version":"current","frontMatter":{"id":"chapter-04","title":"Chapter 4","sidebar_label":"Chapter 4"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3","permalink":"/physical-ai-humanoid-textbook/docs/chapter-03"},"next":{"title":"Chapter 5","permalink":"/physical-ai-humanoid-textbook/docs/chapter-05"}}');var i=t(4848),s=t(8453);const r={id:"chapter-04",title:"Chapter 4",sidebar_label:"Chapter 4"},l=void 0,a={},c=[{value:"Chapter 04: Control Systems",id:"chapter-04-control-systems",level:3},{value:"Learning Objectives",id:"learning-objectives",level:4},{value:"Theory Explanation",id:"theory-explanation",level:4},{value:"Diagrams",id:"diagrams",level:4},{value:"Python/ROS2 Code Examples",id:"pythonros2-code-examples",level:4},{value:"Python: Basic PID Controller Implementation",id:"python-basic-pid-controller-implementation",level:5},{value:"ROS2: Conceptual Joint Position Controller (Pseudocode)",id:"ros2-conceptual-joint-position-controller-pseudocode",level:5},{value:"Exercises + MCQs",id:"exercises--mcqs",level:4},{value:"Exercises",id:"exercises",level:5},{value:"Multiple Choice Questions",id:"multiple-choice-questions",level:5}];function d(e){const n={admonition:"admonition",code:"code",h3:"h3",h4:"h4",h5:"h5",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h3,{id:"chapter-04-control-systems",children:"Chapter 04: Control Systems"}),"\n",(0,i.jsx)(n.h4,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"After studying this chapter, you should be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Explain the fundamental concepts of feedback control systems."}),"\n",(0,i.jsx)(n.li,{children:"Implement and tune Proportional-Integral-Derivative (PID) controllers."}),"\n",(0,i.jsx)(n.li,{children:"Understand the differences between kinematic and dynamic control."}),"\n",(0,i.jsx)(n.li,{children:"Describe advanced control strategies like adaptive and robust control."}),"\n",(0,i.jsx)(n.li,{children:"Develop basic control loops for robot joints using Python/ROS2."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"theory-explanation",children:"Theory Explanation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Control Systems"})," are essential for enabling robots to perform desired actions accurately and stably. The core idea is to regulate a system's behavior by continuously comparing its actual output to a desired setpoint and adjusting inputs to minimize the error."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Feedback Control"})," is the most common paradigm in robotics. It involves measuring the current state of the system (using sensors), comparing it to the desired state, and using the error to calculate corrective control signals. This closed-loop approach allows the robot to compensate for disturbances and uncertainties in the environment."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Proportional-Integral-Derivative (PID) Controllers"})," are ubiquitous in industrial control due to their simplicity and effectiveness. A PID controller calculates an error value as the difference between a desired setpoint and a measured process variable. It then applies a correction based on three terms:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Proportional (P)"}),": Corrects error proportional to its current value. Provides a quick response but can lead to oscillations and steady-state error."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Integral (I)"}),": Corrects for accumulated past errors, eliminating steady-state error but potentially increasing overshoot and instability."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Derivative (D)"}),": Responds to the rate of change of the error, providing damping and reducing overshoot, but can amplify noise."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kinematic Control"})," focuses on controlling the robot's position and velocity in space (task space) without explicitly considering its mass, inertia, or external forces. It relies on the kinematic model (covered in Chapter 2) and is suitable for slower movements or when dynamic effects are negligible."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Control"}),", in contrast, explicitly considers the robot's mass, inertia, gravity, and other forces/torques. It aims to control the robot's acceleration or joint torques directly, enabling faster, more precise, and force-aware movements. Model-based dynamic control often uses inverse dynamics to calculate the joint torques required to achieve desired accelerations."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Advanced Control Strategies"})," include:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Adaptive Control"}),": Modifies controller parameters online to account for uncertainties or changes in robot dynamics or environment."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Robust Control"}),": Designs controllers that maintain desired performance despite significant uncertainties or disturbances."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Impedance Control"}),": Controls the mechanical impedance (relationship between force and velocity) of the robot at the end-effector, allowing for compliant interaction with the environment."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Control of Humanoid Joints"})," is particularly challenging due to high degrees of freedom, complex coupled dynamics, and the need for balance and stability. Techniques often combine hierarchical control (high-level task planning, mid-level whole-body control, low-level joint control) with specialized algorithms for balance, gait generation, and contact management."]}),"\n",(0,i.jsx)(n.h4,{id:"diagrams",children:"Diagrams"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[Desired Setpoint] --\x3e E(Error Calculation);\n    F[Measured Output] --\x3e E;\n    E --\x3e PID(PID Controller);\n    PID --\x3e G[Control Signal];\n    G --\x3e H[Robot Actuators];\n    H --\x3e I[Robot Dynamics / Plant];\n    I --\x3e F;\n\n    subgraph PID Terms\n        P(Proportional) --\x3e PID;\n        I(Integral) --\x3e PID;\n        D(Derivative) --\x3e PID;\n    end\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Figure 4.1: General Feedback Control Loop with PID Controller"})}),"\n",(0,i.jsx)(n.h4,{id:"pythonros2-code-examples",children:"Python/ROS2 Code Examples"}),"\n",(0,i.jsx)(n.h5,{id:"python-basic-pid-controller-implementation",children:"Python: Basic PID Controller Implementation"}),"\n",(0,i.jsx)(n.p,{children:"This example shows a simple Python implementation of a PID controller, often used in simulated or simplified control tasks."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import time\n\nclass PIDController:\n    def __init__(self, kp, ki, kd, setpoint):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.setpoint = setpoint\n        self.prev_error = 0\n        self.integral = 0\n\n    def update(self, current_value, dt):\n        error = self.setpoint - current_value\n        self.integral += error * dt\n        derivative = (error - self.prev_error) / dt\n        output = self.kp * error + self.ki * self.integral + self.kd * derivative\n        self.prev_error = error\n        return output\n\nclass SimulatedMotor:\n    def __init__(self, initial_position=0.0):\n        self.position = initial_position\n        self.velocity = 0.0\n        self.max_velocity = 1.0\n\n    def move(self, control_signal, dt):\n        # Simulate simple motor physics\n        # Control signal is interpreted as desired acceleration or force\n        self.velocity += control_signal * dt * 0.1 # Simplified acceleration effect\n        self.velocity = max(-self.max_velocity, min(self.max_velocity, self.velocity))\n        self.position += self.velocity * dt\n        return self.position\n\nif __name__ == "__main__":\n    # Target position for the motor\n    target_position = 10.0\n\n    # PID gains (these would need tuning for a real system)\n    kp = 0.5\n    ki = 0.1\n    kd = 0.05\n\n    pid = PIDController(kp, ki, kd, target_position)\n    motor = SimulatedMotor(initial_position=0.0)\n\n    dt = 0.1 # simulation time step\n    print(f"Target Position: {target_position:.2f}")\n\n    for i in range(100):\n        current_position = motor.position\n        control_output = pid.update(current_position, dt)\n        new_position = motor.move(control_output, dt)\n\n        print(f"Time: {i*dt:.1f}s, Current Position: {new_position:.2f}, Control Output: {control_output:.2f}")\n\n        if abs(target_position - new_position) < 0.05: # Close enough to target\n            print("Target reached!")\n            break\n        time.sleep(0.01)\n'})}),"\n",(0,i.jsx)(n.h5,{id:"ros2-conceptual-joint-position-controller-pseudocode",children:"ROS2: Conceptual Joint Position Controller (Pseudocode)"}),"\n",(0,i.jsxs)(n.p,{children:["In ROS2, PID controllers are often implemented as part of a ",(0,i.jsx)(n.code,{children:"ros2_control"})," hardware interface or a dedicated controller. Here's a conceptual node that would use PID to control a single joint's position, subscribing to a desired position and publishing motor commands."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# pseudo_joint_controller_node.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64 # For desired position and motor command\nfrom sensor_msgs.msg import JointState # For actual joint position feedback\n\nclass PseudoJointControllerNode(Node):\n    def __init__(self):\n        super().__init__('pseudo_joint_controller')\n        self.declare_parameter('joint_name', 'joint1')\n        self.joint_name = self.get_parameter('joint_name').get_parameter_value().string_value\n\n        # PID gains (would be loaded from parameter server in real ROS2 app)\n        self.kp = 10.0\n        self.ki = 1.0\n        self.kd = 0.5\n        self.setpoint = 0.0\n        self.prev_error = 0.0\n        self.integral = 0.0\n        self.last_time = self.get_clock().now()\n\n        self.desired_pos_sub = self.create_subscription(\n            Float64, f'/joint_command/{self.joint_name}/position', self.setpoint_callback, 10)\n        self.joint_state_sub = self.create_subscription(\n            JointState, '/joint_states', self.joint_state_callback, 10)\n        self.motor_pub = self.create_publisher(\n            Float64, f'/motor_command/{self.joint_name}/effort', 10) # Or velocity/position\n\n        self.control_timer = self.create_timer(0.01, self.control_loop) # 100 Hz control loop\n\n        self.get_logger().info(f'PseudoJointController for {self.joint_name} started.')\n\n    def setpoint_callback(self, msg):\n        self.setpoint = msg.data\n        self.get_logger().info(f'Setpoint for {self.joint_name} updated to: {self.setpoint:.2f}')\n\n    def joint_state_callback(self, msg):\n        # Find the position of our specific joint\n        try:\n            idx = msg.name.index(self.joint_name)\n            self.current_position = msg.position[idx]\n        except ValueError:\n            self.get_logger().warn(f'Joint {self.joint_name} not found in joint_states.')\n            self.current_position = None\n\n    def control_loop(self):\n        if self.current_position is None: return\n\n        current_time = self.get_clock().now()\n        dt = (current_time - self.last_time).nanoseconds / 1e9 # Convert to seconds\n        self.last_time = current_time\n\n        error = self.setpoint - self.current_position\n        self.integral += error * dt\n        derivative = (error - self.prev_error) / dt\n        control_output = self.kp * error + self.ki * self.integral + self.kd * derivative\n        self.prev_error = error\n\n        motor_command = Float64()\n        motor_command.data = control_output\n        self.motor_pub.publish(motor_command)\n        # self.get_logger().info(f'Control loop: pos={self.current_position:.2f}, error={error:.2f}, cmd={control_output:.2f}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = PseudoJointControllerNode()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,i.jsx)(n.h4,{id:"exercises--mcqs",children:"Exercises + MCQs"}),"\n",(0,i.jsx)(n.h5,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"PID Tuning"}),": Explain the likely behavior of a PID controller if:\na.  ",(0,i.jsx)(n.code,{children:"Kp"})," is too high (and ",(0,i.jsx)(n.code,{children:"Ki"}),", ",(0,i.jsx)(n.code,{children:"Kd"})," are zero).\nb.  ",(0,i.jsx)(n.code,{children:"Ki"})," is too high (and ",(0,i.jsx)(n.code,{children:"Kp"}),", ",(0,i.jsx)(n.code,{children:"Kd"})," are reasonable).\nc.  ",(0,i.jsx)(n.code,{children:"Kd"})," is too high (and ",(0,i.jsx)(n.code,{children:"Kp"}),", ",(0,i.jsx)(n.code,{children:"Ki"})," are reasonable) in a noisy environment."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Kinematic vs. Dynamic Control"}),": For a humanoid robot performing a slow, precise pick-and-place task versus a fast, highly dynamic jumping motion, explain why one might prefer kinematic control for the former and dynamic control for the latter."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ROS2 Control"}),": Research the ",(0,i.jsx)(n.code,{children:"ros2_control"})," framework. Briefly describe its main components (e.g., hardware interface, controller manager) and how they facilitate robot control in ROS2."]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"multiple-choice-questions",children:"Multiple Choice Questions"}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["What is the primary role of the Integral term (",(0,i.jsx)(n.code,{children:"Ki"}),") in a PID controller?"]}),(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","To provide a quick response to current error."]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","To eliminate steady-state error by accumulating past errors."]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","To reduce overshoot by reacting to the rate of error change."]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","To filter sensor noise."]}),"\n"]})]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.p,{children:"Which type of robot control explicitly considers the robot's mass, inertia, and external forces?"}),(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Kinematic Control"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Dynamic Control"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Open-loop Control"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Positional Control"]}),"\n"]})]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.p,{children:"A robot operating within a closed-loop control system:"}),(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Does not require sensor feedback."]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Has its actuators directly commanded without correction."]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","Continuously adjusts its actions based on sensor feedback comparing actual to desired states."]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Is immune to environmental disturbances."]}),"\n"]})]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var o=t(6540);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);